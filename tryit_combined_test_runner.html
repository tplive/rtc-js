<!DOCTYPE html>
<html>
<body>
<script>
window.onerror = function(errorMsg, url, lineNumber){
    // any action you want goes here
    // errorMsg is the error message itself.
    // url should be the file presenting the error, though i have
    //    found that it only presents to me the address of the site.
    // lineNumber is the line number the error occoured on.
    // here is an example of what you could do with it:
    const error = document.getElementById("error")
    error.innerHTML = "Error in " + url + " at " + lineNumber + ":\n" + errorMsg
}
</script>

<h1>Test Runner</h1>

<h2>Testing Tuple functions</h2>
<ul id="test_list"></ul>

<h2>Testing Color functions</h2>
<ul id="colors_list"></ul>

<h2>Testing Canvas functions</h2>
<ul id="canvas_list"></ul>

<pre><code id="error"></code></pre>

<script>
// *** FUNCTION DEFINITIONS

const PRECISION = 5
const EPSILON = 1.0*10**(-PRECISION)

function display_msg(domId, msg) {
  const para = document.createElement("p");
  const node = document.createTextNode(msg);
  para.appendChild(node);
  const element = document.getElementById(domId);
  element.appendChild(para);
}

function equal(a, b) {
  // Comparing floating point numbers for equivalence may, due to rounding errors, fail.
  // By subtract a from b and comparing the result to a small constant EPSILON, we
  // can call them equal.
  
  return (Math.abs(a - b) < EPSILON.toFixed(PRECISION))
}

function equal_tuples(a, b) {
  // Compare x, y, z coordinates of a tuple. JS does not distinguish these types of objects
  // so a tuple == vector == point at this time.
  return (equal(a.x, b.x) && equal(a.y, b.y) && equal(a.z, b.z))
}

function display_tuple(a) {
  return `x:${a.x} y:${a.y} z:${a.z} w:${a.w}`
}

function add_tuples(a, b) {
  // Add two tuples together.
  // A point (w=1) added to a vector (w=0) is a new point.
  // A vector (w=0) added to another vector (w=0) is the resulting vector.
  // Adding two points produces w=2 which doesn't make sense.
  return tuple(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w)
}

function subtract_tuples(a, b) {
  // Subtract values of tuple b from values of tuple a.
  return tuple(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w)
}

function negate_tuple(t) {
  // Return a tuple with x=-x, y=-y, z=-z coordinates
  return tuple(t.x * -1, t.y * -1, t.z * -1, t.w * -1)
}

function multiply_vector(s, t) {
  // Multiply each component of the tuple t by the scalar value s
  return tuple(t.x * s, t.y * s, t.z * s, t.w * s)
}

function divide_vector(s, t) {
  // Multiply each component of the tuple t by the scalar value s
  return tuple(t.x / s, t.y / s, t.z / s, t.w / s)
}

function magnitude(v) {
  // Calculate the magnitude of a vector
  return Math.sqrt(v.x**2 + v.y**2 + v.z**2 + v.w**2)
}

function normalize(v) {
  // Normalize a vector using its magnitude
  var m = magnitude(v)
  return tuple(v.x / m, v.y / m, v.z / m, v.w / m)
}

function dot(a, b) {
  // Compute the dot product of two vectors
  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}

function cross(a, b) {
  // Compute the cross product of two vectors
  // Order matters!
  return vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
}

function tuple(a, b, c, d) {
  return Object.freeze({ x:a, y:b, z:c, w:d })
}

function vector(a,b,c) {
  return tuple(a,b,c,0)
}

function point(a,b,c) {
  return tuple(a,b,c,1)
}

// *** COLOR FUNCTIONS

function color(r, g, b) {
  return Object.freeze({ 
    red:r, 
    green:g, 
    blue:b,
    toString: function() { return `red: ${this.red}, green: ${this.green}, blue: ${this.blue}`}})
}

function add_colors(c1, c2) {
  // Adding two colors by simple addition
  return color(c1.red + c2.red, c1.green + c2.green, c1.blue + c2.blue)
}

function subtract_colors(c1, c2) {
  // Subtracting two colors by simple subtraction
  return color(c1.red - c2.red, c1.green - c2.green, c1.blue - c2.blue)
}

function multiply_color(s, c1) {
  // Multiply scalar value by r, g, b components
  return color(s * c1.red, s * c1.green, s * c1.blue)
}

function multiply_colors(c1, c2) {
  // Multiply r, g, b components of two colors by each other
  return color(c1.red * c2.red, c1.green * c2.green, c1.blue * c2.blue)
}

function scale_color(c) {
  // Scale the value of a color between 0-255
  // > 1.0 = 255
  //   1.0 = 255
  //   0.5 = 128
  //   0.0 = 0
  // < 0.0 = 0
  
  let red = 255 * c.red
  red = red > 255 ? 255 : red && red < 0 ? 0 : red
  
  let grn = 255 * c.green
  grn = grn > 255 ? 255 : grn && grn < 0 ? 0 : grn
  
  let blu = 255 * c.blue
  blu = blu > 255 ? 255 : grn && blu < 0 ? 0 : blu
    
  //display_msg("error", color(red, grn, blu).toString())
  
  return color(Math.round(red), Math.round(grn), Math.round(blu))
  
}

// *** CANVAS FUNCTIONS

function html_canvas(parent, width, height) {
  // Creates a canvas element as a child of parent, dimensions specified by width and height.
  // Returns the canvas context.
  
  const can = document.createElement("canvas")
  can.setAttribute("width", width)
  can.setAttribute("height", height)
  can.setAttribute("id", parent + "_canvas")
  document.body.appendChild(can)
  
  return can
}

function html_canvas_to_ppm(canvas) {
  // Take a canvas object and return a PPM file header
  // The header should look like this, where 80 40 is W and H:
  // P3
  // 80 40
  // 255
  
  var str = `P3
${canvas.width} ${canvas.height}
255
`
  return str
}

function canvas(w, h) {
  // Create a canvas abstraction object. It has a width and a height and a pixel array.
  // Each pixel is defined by three values, r, g, b.
  // The format is a single array or bit stream.
  // To make the array as efficient as possible, we make it a const and pre-initialize length.
  // The RTC book assumes all x and y values are 0-based.
  // So 0 < x < w - 1, and 0 < y < h - 1
  
  const b = 3 // Bits per pixel. rgb = 3. rgba = 4.
  const d = Array(w * h * b).fill(0)
  //display_msg("error", `w * h * b = ${w} * ${h} * ${b} = ${d.length}`)
  
  return {
    width:w,
    height:h,
    data:d,
    bits:b,
    pixel_at: function(x, y) {
      // Make sure pixels are within the canvas.
      if (x < 0 || y < 0 || x > w - 1 || y > h - 1) {
        throw `Coordinate values out of bounds: x, y: ${x}, ${y}`
      }
      
      const i = (w * y + x) * b
  
      return color(this.data[i], this.data[i+1], this.data[i+2])
    },
    write_pixel: function(x, y, color) {
    // Make sure pixels are within the canvas.
      if (x < 0 || y < 0 || x > w - 1 || y > h - 1) {
        throw `Coordinate values out of bounds: x, y: ${x}, ${y}`
      }
      const i = (w * y + x) * b
      // For debugging
      //display_msg("error", `w: ${w} h: ${h} x: ${x} y: ${y} i: ${i} color: ${color.toString()} `)
      
      this.data[i]   = color.red
      this.data[i+1] = color.green
      this.data[i+2] = color.blue
      //display_msg("error", `write_pixel: ${this.data[i]}, ${this.data[i+1]}, ${this.data[i+2]}`)
    }
    }
}

function canvas_to_ppm(canvas) {
  // Take a canvas object and return a PPM file.
  // The header should look like this, where 80 40 is W and H:
  // P3
  // 80 40
  // 255
  
  const pixels = Math.floor(canvas.width * canvas.height )
  const max_ppm_width = 70
  const elements_per_line = Math.floor(max_ppm_width / canvas.bits)
  const lines = Math.floor(pixels / elements_per_line)
  
  display_msg("error", "Lines: " + lines)
  display_msg("error", "Pixels per line: " + elements_per_line)
  
  for (let k in canvas.data) {
    if ( k % elements_per_line === 0) {
      canvas.data.splice( k, 0, `\n`)
    }
  }
  
  var str = `P3
${canvas.width} ${canvas.height}
255
${canvas.data.join(" ")}
`
  return str
}

</script>
<script>
// *** TESTS
function test_tuple_function() {
  // Constructing a tuple with x=1, y=2, z=3, w=1 should return a tuple object with matching values

  var t = tuple(1, 2, 3, 1)

  return (t.x == 1 && t.y == 2 && t.z == 3 && t.w == 1)
}

function test_vector_function() {
  // Constructing a vector with x=-3.5, y=2.211, z=0.001 should return a tuple object with matching values and w=0

  var v = vector(-3.5, 2.211, 0.001)
  

  return (v.x == -3.5 && v.y == 2.211 && v.z == 0.001 && v.w == 0)
}

function test_point_function() {
  // Constructing a point with x=143.556, y=-900.88, z=555.555 should return a tuple object with matching values and w=1

  var v = point(143.556, -900.88, 555.555)
  

  return (v.x == 143.556 && v.y == -900.88 && v.z == 555.555 && v.w == 1)
}

function test_equal_function() {
  // Comparing floating point numbers for equivalence may, due to rounding errors, fail
  // The function equal(a, b) will subtract a from b and compare the result to a small constant EPSILON.
  // and if the difference is smaller, we will call them equal.

  return (equal(1.0, 1.0) && !(equal(12.009, 12.008)) && equal(123456.2345, 123456.234501))
}

function test_equal_tuples_function() {
  // Test that tuple, vector and point coordinates are the same, even with slight diff outside PRECISION value

  var t = tuple(110.999, -23.11, 2, 2)
  var v = vector(110.999, -23.11, 2.0)
  var p = point(110.9990000001, -23.11, 2.00000001)

  return (equal_tuples(t, v) && equal_tuples(v, p) && equal_tuples(p, t))
}

function test_add_tuples_function() {

  var t = tuple(110.999, -23.11, 2, 0)
  var v = vector(1.999, 23.11, 22.001)
  var p = point(110.9990000001, -23.11, 2.00000001)
  
  var result_tv = tuple(112.998, 0.0, 24.001, 1)

  return (equal_tuples(add_tuples(t, v), result_tv))
}

function test_subtract_tuples_function() {

  var t = tuple(-44.555, 345.123, 1.0, 0)
  var v = vector(-33.44, 123.345, 0.0)

  var subtracted_tv = subtract_tuples(t, v)
  
  return (equal_tuples(subtracted_tv, tuple(t.x - v.x, t.y - v.y, t.z - v.z, t.w - v.w)))
}

function test_negate_tuple_function() {
  // Test that negate_tuple() returns a tuple with x=-x, y=-y, z=-z coordinates
  
  var n = negate_tuple(tuple(1, -2, 3, -4))
  return (n.x == -1, n.y == 2, n.z == -3, n.w == 4 )
}

function test_multiply_vector_function() {
  // Multiplying a tuple by a scalar
  // Given t = tuple(1, -2, 3, -4)
  // Then t * 3.5 = tuple(3.5, -7, 10.5, -14)
  
  var m = multiply_vector(3.5, tuple(1, -2, 3, -4))
  return (equal(m.x, 3.5) && equal(m.y, -7) && equal(m.z, 10.5) && equal(m.w, -14))
}

function test_divide_vector_function() {
  // Dividing a tuple by a scalar value
  // Given t = tuple(1, -2, 3, -4)
  // Then t / 2 = tuple(0.5, -1, 1.5, -2)
  
  var t = divide_vector(2, tuple(1, -2, 3, -4))
  var t_result = (equal(t.x, 0.5) && equal(t.y, -1) && equal(t.z, 1.5) && equal(t.w, -2))
    
  return (t_result)
}

function test_magnitude_function() {
  // Magnitude, or length of a vector is the distance from one end of a vector to the other.
  // Given vector(x, y, z, 0), the magnitude is Math.sqrt(x**2 + y**2 + z**2 + w**2)
  
  var r = magnitude(vector(0, 1, 0))
  var s = magnitude(vector(0, 0, 1))
  var t = magnitude(vector(1, 2, 3))
  var u = magnitude(vector(-1, -2, -3))
  
  return (equal(r, 1) && equal(s, 1), equal(t, Math.sqrt(14)) && equal(u, Math.sqrt(14)))
}

function test_normalize_function() {
  // Normalizing a vector means taking an arbitrary vector and converting it into a unit vector.
  // Normalizing vector(4, 0, 0) gives (1, 0, 0)
  // Normalizing vector(1, 2, 3) gives vector(1/sqrt(14, 2/sqrt(14), 3/sqrt(14))
  // The magnitude of a normalized vector is 1.
  
  var a = normalize(vector(4, 0, 0))
  var b = normalize(vector(1, 2, 3))
  
  return (equal_tuples(a, vector(1, 0, 0)) && equal_tuples(b, vector(1/Math.sqrt(14), 2/Math.sqrt(14), 3/Math.sqrt(14))))
  
}

function test_dot_function() {
  // Compute the dot product (aka scalar product) of two vectors
  // Given vector(1, 2, 3) and vector(2, 3, 4) the dot product is 20
  
  return (dot(vector(1, 2, 3), vector(2, 3, 4)) == 20)
}

function test_cross_function() {
  // The cross product is the same as the dot product, only it returns a vector instead of a scalar value.
  // Gives vector(1, 2, 3) and vector(2, 3, 4)
  // Then cross(a, b) == vector(-1, 2, -1)
  // and cross(b, a) == vector(1, -2, 1)
  var u = vector(1, 2, 3)
  var v = vector(2, 3, 4)
  
  var uv = cross(u, v)
  var vu = cross(v, u)
  
  return (equal_tuples(uv, vector(-1, 2, -1)) && equal_tuples(vu, vector(1, -2, 1)))
}

// *** COLOR TESTS

function test_color_function() {
  // Colors are tuples too!
  // Test creating a color(r, g, b) object
  var c = color(-0.5, 0.4, 1.7)
  return (c.red == -0.5 && c.green == 0.4 && c.blue == 1.7)
}

function test_add_colors_function() {
  // Adding two colors means simple addition of their r, g and b values.
  
  var c1 = color(0.9, 0.6, 0.75)
  var c2 = color(0.7, 0.1, 0.25)
  
  var c3 = add_colors(c1, c2)
  return (c3.red == c1.red + c2.red && c3.blue == c1.blue + c2.blue && c3.green == c1.green + c2.green) 
}

function test_subtract_colors_function() {
  // Subtracting two colors means simple subtraction of their r, g and b values.
  
  var c1 = color(0.9, 0.6, 0.75)
  var c2 = color(0.7, 0.1, 0.25)
  
  var c3 = subtract_colors(c1, c2)
  return (c3.red == c1.red - c2.red && c3.blue == c1.blue - c2.blue && c3.green == c1.green - c2.green) 
}

function test_multiply_color_function() {
  // Multiply r, g and b values by a scalar value.
  
  var c1 = color(0.9, 0.6, 0.75)
  var scalar = 1.5
  
  var c3 = multiply_color(scalar, c1)
  return (c3.red == c1.red * scalar && c3.blue == c1.blue * scalar && c3.green == c1.green * scalar) 
}

function test_multiply_colors_function() {
  // Multiply r, g and b values of two colors by each other.
  
  var c1 = color(0.9, 0.6, 0.75)
  var c2 = color(0.7, 0.1, 0.25)
    
  var c3 = multiply_colors(c1, c2)
  return (c3.red == c1.red * c2.red && c3.blue == c1.blue * c2.blue && c3.green == c1.green * c2.green) 
}

function test_scale_color_function() {
  // Scale color to value suitable for PPM file.
  // min = 0
  // max = 255
  // color = color object to be scaled.
  // return a new color object
  
  const min = 0   // Minimum scaled value
  const max = 255 // Maximum scaled value
  
  const c1 = color(0.9, -1.5, 2)
  const s1 = scale_color(c1)
  
  return (s1.red === 230 && s1.green === 0 && s1.blue === 255)
  
}

function test_html_canvas_function() {
  // Creates a canvas initialized to all black pixels.
  // ID of canvas element is that of its parent, suffixed with "_canvas"
  
  var parent = "canvas_list"
  var w = 10
  var h = 20
  
  const can = html_canvas(parent, w, h)
  const context = can.getContext("2d")
  context.fillStyle = "black"
  context.fillRect(0, 0, w, h)
  
  
  
  return !!document.getElementById(parent + "_canvas")
}

function test_html_get_pixel_color_function() {
  // Create canvas, set a pixel to a given color value.
  // Read color value, compare.
  
  const parent = "canvas_list"
  const w = 10
  const h = 20
  
  const can = html_canvas(parent, w, h)
  const ctx = can.getContext("2d")
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, w, h)
  ctx.fillStyle = "red"
  ctx.fillRect(2, 2, 3, 3)
  
  const imgData = ctx.getImageData(2, 2, 1, 1)
  const c1 = color(255, 0,0)
  const c2 = color(imgData.data[0], imgData.data[1], imgData.data[2])
  
  return (c1.red == c2.red && c1.green == c2.green && c1.blue == c2.blue)
}

function test_html_canvas_to_ppm_function() {
  // Will convert canvas data to a valid ppm file header.
  // Given a canvas of 80x40 pixels, the header should look like this:
  // P3
  // 80 40
  // 255
  
  const can = html_canvas("body", 80, 40)
  const ppm = html_canvas_to_ppm(can)
  
  return (ppm === `P3\n80 40\n255\n`)
}

function test_canvas_function() {
  // This is a test for a canvas function that is pure data, not the HTML element called canvas.
  // A canvas is an object with width, height and a data array for pixel values.
  const w = 12
  const h = 12
  var can = canvas(w, h)
  
  // Test all values are 0.
  let sum = 0
  for (let key in can.data) {
    sum += can.data[key];
  }
  const valzero = sum === 0
    
  const i = 11
  can.data[11] = 255
  can.data[11+1] = 123
  can.data[11+2] = 234
  //display_msg("error", "at i=11: " + can.data[11])
  return (can.width === w && can.height === h && can.data[11] === 255 && can.data[11+1] === 123 && can.data[11+2] === 234 && can.data[1] == 0 && valzero)
}

function test_write_pixel_function() {
  // Given a canvas, write a color to a pixel at desired coordinates and test reading the value.
  // To get pixel index value: w * y + x * b
  const w = 8
  const h = 8
  const can = canvas(w, h)
  const c1 = color(11, 22, 33)
  const len = can.data.length
  
  can.write_pixel(2, 2, c1)

  if(can.data.length > len) {
    display_msg("error", "Array has been lengthened! Was: " + len + " and now: " + can.data.length )
    return false
  }
  const p1 = can.pixel_at(2, 2)
  
  //display_msg("error", `p1index: ${p1index} +1: ${p1index+1} +2x: ${p1index+2}`)
  //display_msg("error", `p1index: ${can.data[p1index]} +1: ${can.data[p1index+1]} +2x: ${can.data[p1index+2]}`)
  return (p1.red === c1.red && p1.green === c1.green && p1.blue === c1.blue) 
}

function test_catch_canvas_out_of_bounds() {
  // Given a canvas, test that writing pixels or reading outside bounds will throw an exception.
  const w = 7
  const h = 6
  const can = canvas(w, h)
  const c1 = color(110, 220, 330) // Color values are unbounded for calculations, but cannot exceed 255 in display.
  
  var errors = [] // An array of errors from tests below
  
  var t1, t2, t3, t4, t5 = false
  try {
    can.write_pixel(4, 5, c1) // Should not fail
    can.pixel_at(4, 5, c1) // Should not fail
  } catch (err) {
    errors.push(err)
    t1 = true
  }
  
  try {
    can.write_pixel(-1, 1) // -1 is out of bounds
  } catch (err) {
    errors.push(err)
    t2 = true
  }
      
  try {
      can.write_pixel(1, -1) // -1 is out of bounds
  } catch (err) {
    errors.push(err)
    t3 = true
  }
  
  try {
    can.write_pixel(w, h + 1) // y > h is out of bounds
  } catch (err) {
    errors.push(err)
    t4 = true
  }
  
  try {
    can.write_pixel(w + 1, h) // x > w is out of bounds
  } catch (err) {
    errors.push(err)
    t5 = true
  }
  
  //display_msg("error", "Failed tests: " + errors.join("\n"))
    
  return ( !t1 && t2 && t3 && t4 && t5 ) 
}

function test_constructing_ppm_header() {
  // PPM header test
  // The header should look like this, where 80 40 is W and H:
  // P3
  // 80 40
  // 255
  
  const w = 80
  const h = 40
  const c = canvas(w, h)
  
  c.data = []
  ppm = canvas_to_ppm(c)
  //display_msg("error", ppm)
  
  return (ppm === `P3\n80 40\n255\n\n`)
}

function test_canvas_to_ppm_function() {
  // Test function for making a ppm file from a canvas.
  const w = 4
  const h = 4
  const can = canvas(w, h)
  
  can.write_pixel(0,0, color(1, 1, 1))
  can.write_pixel(1,0, color(2, 2, 2))
  can.write_pixel(0,1, color(3, 3, 3))
  can.write_pixel(1,1, color(4, 4, 4))
  
  const ppm = canvas_to_ppm(can)
  
  //display_msg("error", ppm)
  return (ppm === `P3\n4 4\n255\n1 1 1 2 2 2 0 0 0 0 0 0 3 3 3 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n`)
  
}
</script>
<script>
// *** RUN TESTS, DISPLAY RESULTS

function runTest(domId, callback) {
  
  // Get list and create a new list item
  const ul = document.getElementById(domId)
  const li = document.createElement("li")
  
  // Create placeholder inside list item
  const li_text = document.createElement("span")
  li_text.innerHTML = "Running " + callback.name + "(): "
  
  // Append list item to list
  ul.appendChild(li);
  // Append span to list item
  li.appendChild(li_text)
  
  // Run test
  var result = callback()
  
  const li_result = document.createElement("span")
  li.appendChild(li_result)
  var text = (result) ? "Test Passed!":"Test Failed!"
  var color = (result) ? "green":"red"
  li_result.innerHTML = text
  li_result.style.color = color

}

function test_ppm_pixel_data() {
  // Test pixel data is valid.
  // File should end with newline.
  // No line should exceed 70 characters, and must not split a color in two.
  // Colors must be scaled to values between 0 and 255.
  
  const w = 24
  const h = 11
  const can = canvas(w, h)
  const c1 = color(1.0, 0.55432, 0.4)
  
  const scaled_color = scale_color(c1)
    
  for (let x = 0; x < w; x++) {
    for (let y = 0; y < h; y++) {
      can.write_pixel(x, y, scale_color(c1))
    }
  }
  
  const ppm = canvas_to_ppm(can)
  display_msg("error", ppm)
 
  return false
  
}

runTest("test_list", test_tuple_function)
runTest("test_list", test_vector_function)
runTest("test_list", test_point_function)
runTest("test_list", test_equal_function)
runTest("test_list", test_equal_tuples_function)
runTest("test_list", test_add_tuples_function)
runTest("test_list", test_subtract_tuples_function)
runTest("test_list", test_negate_tuple_function)
runTest("test_list", test_multiply_vector_function)
runTest("test_list", test_divide_vector_function)
runTest("test_list", test_magnitude_function)
runTest("test_list", test_normalize_function)
runTest("test_list", test_dot_function)
runTest("test_list", test_cross_function)

runTest("colors_list", test_color_function)
runTest("colors_list", test_add_colors_function)
runTest("colors_list", test_subtract_colors_function)
runTest("colors_list", test_multiply_color_function)
runTest("colors_list", test_multiply_colors_function)
runTest("colors_list", test_scale_color_function)

runTest("canvas_list", test_canvas_function)
runTest("canvas_list", test_write_pixel_function)
runTest("canvas_list", test_catch_canvas_out_of_bounds)
runTest("canvas_list", test_constructing_ppm_header)
runTest("canvas_list", test_ppm_pixel_data)
runTest("canvas_list", test_canvas_to_ppm_function)

</script>

</body>

</html>