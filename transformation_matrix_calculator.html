<!DOCTYPE html>
<html>

<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
<style>

@import url('https://fonts.googleapis.com/css?family=Coda|Crimson+Text|Gothic+A1|M+PLUS+1p|M+PLUS+Rounded+1c|Nanum+Gothic|Nanum+Myeongjo|Noto+Sans&display=swap');

pre {
  background-color: lightgrey;
}

body {
  font-family: Crimson Text;
  font-size: 1.3rem;
}



input {
  font-family: Coda;
}
table, th , td  {
  border: 1px solid grey;
  border-collapse: collapse;
  padding-left: 1.2rem;
  padding-right: 1.2rem;
}

.outer {
  display: grid;
}

.container {
  margin: 3rem;
}
.matrix {
  margin: 1rem;
  width: auto;
  padding: 10px;
  float: left;
  border: 1px solid grey;
  border-collapse: collapse;
}
.explanation {

}

.tbl-explanation {
  
}
.calculation {

}

.tbl-calculation {

}

.result {
  display:grid;
  margin-left: auto;
  margin-right: auto;
}


</style>
<body ng-app="matrixCalc" ng-controller="matrixCtrl">
<script>
const start = performance.now()

window.onerror = function(errorMsg, url, lineNumber){
    const error = document.getElementById("error")
    error.innerHTML = "Error in " + url + " at " + lineNumber + ":\n" + errorMsg
}
</script>

<script src="./js/matrixCalc.js"></script>
<script src="./js/matrixController.js"></script>
<script>
  // *** MATRIX TRANSFORMATIONS CALCULATOR ANGULAR APP
  var app = angular.module('matrixCalc', [])
  
</script>

<script>
  // *** MATRIX TRANSFORMATIONS CALCULATOR ANGULAR CONTROLLER
  var controller = app.controller('matrixCtrl', function($scope) {
    
    $scope.trx = 0.0
    $scope.try = 0.0
    $scope.trz = 0.0
    $scope.tra = function() {
      return translation($scope.trx, $scope.try, $scope.trz).d
    }
    
    $scope.scx = 1.0
    $scope.scy = 1.0
    $scope.scz = 1.0
    $scope.sca = function() {
      return scaling($scope.scx, $scope.scy, $scope.scz).d
    }
    
    $scope.rotx = 0.0
    $scope.rotxc = function() {
      return rotation_x($scope.rotx).d
    }
    
    $scope.roty = 0.0
    $scope.rotyc = function() {
      return rotation_y($scope.roty).d
    }

    $scope.rotz = 0.0
    $scope.rotzc = function() {
      return rotation_z($scope.rotz).d
    }
    
    $scope.xy = 0.0
    $scope.xz = 0.0
    $scope.yx = 0.0
    $scope.yz = 0.0
    $scope.zx = 0.0
    $scope.zy = 0.0
    $scope.shec = function() {
      return shearing($scope.xy, $scope.xz, $scope.yx, $scope.yz, $scope.zx, $scope.zy).d
    }
    
    $scope.res = function() {
      
      return transformations(
        shearing($scope.xy, $scope.xz, $scope.yx, $scope.yz, $scope.zx, $scope.zy),
        rotation_z($scope.rotz),
        rotation_y($scope.roty),
        rotation_x($scope.rotx),
        
        translation($scope.trx, $scope.try, $scope.trz),
        scaling($scope.scx, $scope.scy, $scope.scz),
      ).d
    }
    
  })

</script>

<h1>&#128526; MATRIX CALCULATOR</h1>
<p>This is a calculator that visualises how the transformation matrix calculations work.</p>
<p>Rotations are given in radians, refer to the unit circle for values. 2&pi; is one full rotation.</p>
<p>Scaling has been given a default value of 1, 1, 1 to keep it from nulling out all other operations.</p>

<div class="outer">
  <div class="container">

    <div class="matrix">
      <div class="explanation">
        <p><b>translation(x, y, z)</b></p>
        <table class="tbl-explanation">
          <tr><td>1</td><td>0</td><td>0</td><td><b>x</b></td></tr>
          <tr><td>0</td><td>1</td><td>0</td><td><b>y</b></td></tr>
          <tr><td>0</td><td>0</td><td>1</td><td><b>z</b></td></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
        </table>
      </div>
      <div class="calculation">
        <p>translation(<input size="2" type="text" ng-model="trx">, <input size="2" type="text" ng-model="try">, <input size="2" type="text" ng-model="trz">)</p>
        <table class = "tbl-calculation">
          <tr><td>{{tra()[0]}}</td><td>{{tra()[1]}}</td><td>{{tra()[2]}}</td><td>{{tra()[3]}}</td></tr>
          <tr><td>{{tra()[4]}}</td><td>{{tra()[5]}}</td><td>{{tra()[6]}}</td><td>{{tra()[7]}}</td></tr>
          <tr><td>{{tra()[8]}}</td><td>{{tra()[9]}}</td><td>{{tra()[10]}}</td><td>{{tra()[11]}}</td></tr>
          <tr><td>{{tra()[12]}}</td><td>{{tra()[13]}}</td><td>{{tra()[14]}}</td><td>{{tra()[15]}}</td></tr>
        </table>
      </div>
    </div>


    <div class="matrix">
      <div class="explanation">
        <p><b>scaling(x, y, z)</b></p>
        <table class="tbl-explanation">
          <tr><td><b>x</b></td><td>0</td><td>0</td><td>0</td></tr>
          <tr><td>0</td><td><b>y</b></td><td>0</td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td><b>z</b></td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
        </table>
      </div>
      <div class="calculation">
        <p>scaling(<input size="2" type="text" ng-model="scx">, <input size="2" type="text" ng-model="scy">, <input size="2" type="text" ng-model="scz">)</p>
        <table class = "tbl-calculation">
          <tr><td>{{sca()[0]}}</td><td>{{sca()[1]}}</td><td>{{sca()[2]}}</td><td>{{sca()[3]}}</td></tr>
          <tr><td>{{sca()[4]}}</td><td>{{sca()[5]}}</td><td>{{sca()[6]}}</td><td>{{sca()[7]}}</td></tr>
          <tr><td>{{sca()[8]}}</td><td>{{sca()[9]}}</td><td>{{sca()[10]}}</td><td>{{sca()[11]}}</td></tr>
          <tr><td>{{sca()[12]}}</td><td>{{sca()[13]}}</td><td>{{sca()[14]}}</td><td>{{sca()[15]}}</td></tr>
        </table>
      </div>
    </div>


    <div class="matrix">
      <div class="explanation">
        <p><b>rotation_x(rad)</b></p>
        <table class="tbl-explanation">
          <tr><td>1</td><td>0</td><td>0</td><td>0</td></tr>
          <tr><td>0</td><td><b>cos(rad)</b></td><td><b>-sin(rad)</b></td><td>0</td></tr>
          <tr><td>0</td><td><b>sin(rad)</b></td><td><b>cos(rad)</b></td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
        </table>
      </div>
      <div class="calculation">
        <p>rotation_x(<input size="2" type="text" ng-model="rotx">)</p>
        <table class = "tbl-calculation">
          <tr><td>{{rotxc()[0]}}</td><td>{{rotxc()[1]}}</td><td>{{rotxc()[2]}}</td><td>{{rotxc()[3]}}</td></tr>
          <tr><td>{{rotxc()[4]}}</td><td>{{rotxc()[5]}}</td><td>{{rotxc()[6]}}</td><td>{{rotxc()[7]}}</td></tr>
          <tr><td>{{rotxc()[8]}}</td><td>{{rotxc()[9]}}</td><td>{{rotxc()[10]}}</td><td>{{rotxc()[11]}}</td></tr>
          <tr><td>{{rotxc()[12]}}</td><td>{{rotxc()[13]}}</td><td>{{rotxc()[14]}}</td><td>{{rotxc()[15]}}</td></tr>
        </table>
      </div>
    </div>

    <div class="matrix">
      <div class="explanation">
        <p><b>rotation_y(rad)</b></p>
        <table class="tbl-explanation">
          <tr><td><b>cos(rad)</b></td><td>0</td><td><b>sin(rad)</b></td><td>0</td></tr>
          <tr><td>0</td><td>1</td><td>0</td><td>0</td></tr>
          <tr><td><b>-sin(rad)</b></td><td>0</td><td><b>cos(rad)</b></td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
        </table>
      </div>
      <div class="calculation">
        <p>rotation_y(<input size="2" type="text" ng-model="roty">)</p>
        <table class = "tbl-calculation">
          <tr><td>{{rotyc()[0]}}</td><td>{{rotyc()[1]}}</td><td>{{rotyc()[2]}}</td><td>{{rotyc()[3]}}</td></tr>
          <tr><td>{{rotyc()[4]}}</td><td>{{rotyc()[5]}}</td><td>{{rotyc()[6]}}</td><td>{{rotyc()[7]}}</td></tr>
          <tr><td>{{rotyc()[8]}}</td><td>{{rotyc()[9]}}</td><td>{{rotyc()[10]}}</td><td>{{rotyc()[11]}}</td></tr>
          <tr><td>{{rotyc()[12]}}</td><td>{{rotyc()[13]}}</td><td>{{rotyc()[14]}}</td><td>{{rotyc()[15]}}</td></tr>
        </table>
      </div>
    </div>

    <div class="matrix">
      <div class="explanation">
        <p><b>rotation_z(rad)</b></p>
        <table class="tbl-explanation">
          <tr><td><b>cos(rad)</b></td><td><b>-sin(rad)</b></td><td>0</td><td>0</td></tr>
          <tr><td><b>sin(rad)</b></td><td><b>cos(rad)</b></td><td>0</td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>1</td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
        </table>
      </div>
      <div class="calculation">
        <p>rotation_z(<input size="2" type="text" ng-model="rotz">)</p>
        <table class = "tbl-calculation">
          <tr><td>{{rotzc()[0]}}</td><td>{{rotzc()[1]}}</td><td>{{rotzc()[2]}}</td><td>{{rotzc()[3]}}</td></tr>
          <tr><td>{{rotzc()[4]}}</td><td>{{rotzc()[5]}}</td><td>{{rotzc()[6]}}</td><td>{{rotzc()[7]}}</td></tr>
          <tr><td>{{rotzc()[8]}}</td><td>{{rotzc()[9]}}</td><td>{{rotzc()[10]}}</td><td>{{rotzc()[11]}}</td></tr>
          <tr><td>{{rotzc()[12]}}</td><td>{{rotzc()[13]}}</td><td>{{rotzc()[14]}}</td><td>{{rotzc()[15]}}</td></tr>
        </table>
      </div>
    </div>

    <div class="matrix">
      <div class="explanation">
        <p><b>shearing(x<sub>y</sub>, x<sub>z</sub>, y<sub>x</sub>, y<sub>z</sub>, z<sub>x</sub>, z<sub>y</sub>)</b></p>
        <table class="tbl-explanation">
          <tr><td>1</td><td><b>x<sub>y</sub></b></td><td><b>x<sub>z</sub></b></td><td>0</td></tr>
          <tr><td><b>y<sub>x</sub></b></td><td>1</td><td><b>y<sub>z</sub></b></td><td>0</td></tr>
          <tr><td><b>z<sub>x</sub></b></td><td><b>z<sub>y</sub></b></td><td>1</td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
        </table>
      </div>
      <div class="calculation">
        <p>shearing(<input size="2" type="text" ng-model="xy">, <input size="2" type="text" ng-model="xz">, <input size="2" type="text" ng-model="yx">, <input size="2" type="text" ng-model="yz">, <input size="2" type="text" ng-model="zx">, <input size="2" type="text" ng-model="zy">)</p>
        <table class = "tbl-calculation">
          <tr><td>{{shec()[0]}}</td><td>{{shec()[1]}}</td><td>{{shec()[2]}}</td><td>{{shec()[3]}}</td></tr>
          <tr><td>{{shec()[4]}}</td><td>{{shec()[5]}}</td><td>{{shec()[6]}}</td><td>{{shec()[7]}}</td></tr>
          <tr><td>{{shec()[8]}}</td><td>{{shec()[9]}}</td><td>{{shec()[10]}}</td><td>{{shec()[11]}}</td></tr>
          <tr><td>{{shec()[12]}}</td><td>{{shec()[13]}}</td><td>{{shec()[14]}}</td><td>{{shec()[15]}}</td></tr>
        </table>
      </div>
    </div> 
</div>
    <div class="result">
      <p><b>Resulting transformation matrix</b></p>
      <table class = "tbl-calculation">
        <tr><td>{{res()[0]}}</td><td>{{res()[1]}}</td><td>{{res()[2]}}</td><td>{{res()[3]}}</td></tr>
        <tr><td>{{res()[4]}}</td><td>{{res()[5]}}</td><td>{{res()[6]}}</td><td>{{res()[7]}}</td></tr>
        <tr><td>{{res()[8]}}</td><td>{{res()[9]}}</td><td>{{res()[10]}}</td><td>{{res()[11]}}</td></tr>
        <tr><td>{{res()[12]}}</td><td>{{res()[13]}}</td><td>{{res()[14]}}</td><td>{{res()[15]}}</td></tr>
      </table>
    </div>

  </div>

<p id="perf"></p>
<pre id="error"></pre>



<script>
// *** FUNCTION DEFINITIONS


// *** CONFIGURATION OBJECT
const C = function() {
  // The configuration object holds all "global" objects, arrays and configuration values in one place.
  // Should be initialized on startup.
  
  const _precision = 5
  const _epsilon = 1.0*10**(-_precision)
  
  var _counter = 0
  
  var _intersections = []
  var config = {
    a:1,
    b:2
  }
  function init(){
  }
  function scroll(){
  }
  function highlight(){
  }
  return {
    PRECISION:_precision,
    EPSILON:_epsilon,
    intersections:_intersections,
    unique_id: function unique_id() {return _counter++}
  }
}();

// *** HELPER FUNCTIONS

function log(domId, msg) {
    
  const para = document.createElement("p");
  const node = document.createTextNode(msg);
  para.appendChild(node);
  const element = document.getElementById(domId);
  element.appendChild(para);
}

function downloadPPMfile(can, name) {
  // Download PPM file. Takes canvas and file firstname as input.
  
  var dataStr = "data:text/ppm;charset=utf-8," + encodeURIComponent(canvas_to_ppm(can))
  var downloadAnchorNode = document.createElement("a")
  downloadAnchorNode.innerHTML = "Click here to download file " + name + ".ppm"
  downloadAnchorNode.setAttribute("href",     dataStr)
  downloadAnchorNode.setAttribute("download", name + ".ppm")
  document.getElementById("error").appendChild(downloadAnchorNode)
}

function shuffle(arr) {
  // Durstenfeld shuffle algoritm. Found here: https://stackoverflow.com/a/12646864

  for (let i = arr.length - 1; i > 0; i--) {

    const j = Math.floor(Math.random() * (i + 1))
    var temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
  }
}

// *** VECTOR FUNCTIONS

function equal(a, b) {
  // Comparing floating point numbers for equivalence may, due to rounding errors, fail.
  // By subtract a from b and comparing the result to a small constant EPSILON, we
  // can call them equal.
  
  return (Math.abs(a - b) < C.EPSILON.toFixed(C.PRECISION))
}

function equal_tuples(a, b) {
  throw (`equal_tuples() is deprecated. Use tuple().equals(t) instead.`)
  // Compare x, y, z coordinates of a tuple. JS does not distinguish these types of objects
  // so a tuple == vector == point at this time.
  return equal(a.x, b.x) && equal(a.y, b.y) && equal(a.z, b.z) && equal(a.w, b.w)
}

function add_tuples(a, b) {
  throw (`add_tuples() is deprecated. Use tuple().plus(t) instead.`)
  // Add two tuples together.
  // A point (w=1) added to a vector (w=0) is a new point.
  // A vector (w=0) added to another vector (w=0) is the resulting vector.
  // Adding two points produces w=2 which doesn't make sense.
  return tuple(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w)
}

function subtract_tuples(a, b) {
  throw (`subtract_tuples() is deprecated. Use tuple().minus(t) instead.`)
  // Subtract values of tuple b from values of tuple a.
  return tuple(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w)
}

function negate_tuple(t) {
  throw (`negate_tuple() is deprecated. Use tuple().negate() instead.`)
  // Return a tuple with x=-x, y=-y, z=-z coordinates
  return tuple(t.x * -1, t.y * -1, t.z * -1, t.w * -1)
}

function multiply_vector(v, s) {
  throw (`multiply_vector() is deprecated. Use vector().by_scalar(s) instead.`)
  // Multiply each component of the tuple t by the scalar value s
  return tuple(v.x * s, v.y * s, v.z * s, v.w * s)
}

function divide_vector(s, t) {
  throw (`divide_vector() is deprecated. Use vector().divided_by(s) instead.`)
  // Multiply each component of the tuple t by the scalar value s
  return tuple(t.x / s, t.y / s, t.z / s, t.w / s)
}

function magnitude(v) {
  throw (`magnitude() is deprecated. Use vector().magnitude() instead.`)
  // Calculate the magnitude of a vector
  return Math.sqrt(v.x**2 + v.y**2 + v.z**2 + v.w**2)
}

function normalize(v) {
  throw (`normalize() is deprecated. Use vector.normalize() instead.`)
  // Normalize a vector using its magnitude
  var m = magnitude(v)
  return tuple(v.x / m, v.y / m, v.z / m, v.w / m)
}

function dot(a, b) {
  throw (`dot() is deprecated. Use vector.dot(v) instead.`)
  // Compute the dot product of two vectors
  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}

function cross(a, b) {
  throw (`cross() is deprecated. Use vector.cross(v) instead.`)
  // Compute the cross product of two vectors
  // Order matters!
  return vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
}

function tuple(a, b, c, d) {
  return Object.freeze({ 
    x:a,
    y:b,
    z:c,
    w:d,
    equals: function(t) { return equal(a, t.x) && equal(b, t.y) && equal(c, t.z) && equal(d, t.w) },
    minus: function(t) { return tuple(parseFloat(a - t.x), parseFloat(b - t.y), parseFloat(c - t.z), parseInt(d - t.w)) },
    plus: function(t) { return tuple(parseFloat(a + t.x), parseFloat(b + t.y), parseFloat(c + t.z), parseInt(d + t.w)) },
    negate: function() { return tuple(a * -1, b * -1, c * -1, d * -1) },
    by_scalar: function(s) { 
      if (d === 0) {
        return tuple(a * s, b * s, c * s, d * s)
      } else {
        throw(`Can only multiply vectors by scalar value.`)
      }
    },
    divided_by: function(s) {
      if (d === 0) {
        return tuple(a / s, b / s, c / s, d / s)
      } else {
        throw(`Can only divide vectors by scalar value.`)
      }
    },
    dot: function(v) {
      if (d === 0) {
        return a * v.x + b * v.y + c * v.z
      } else {
        throw(`Can only calculate dot product of vectors.`)
      }
    },
    cross: function(v) {
      if (d === 0) {
        return vector(b * v.z - c * v.y, c * v.x - a * v.z, a * v.y - b * v.x)
      } else {
        throw(`Can only calculate cross product of vectors.`)
      }
    },
    magnitude: function() {
    if (d === 0) {
        return Math.sqrt(a**2 + b**2 + c**2)
      } else {
        throw(`Can only calculate magnitude of vectors.`)
      }
      
    },
    normalize: function() {
      if (d === 0) {
        var m = this.magnitude()
        return vector(a / m, b / m, c / m)
      } else {
        throw(`Can only normalize vectors.`)
      }
    },
    toString: function() { return `x:${a} y:${b} z:${c} w:${d}` },
  })
    
}

function vector(a,b,c) {
  return tuple(a,b,c,0)
}

function point(a,b,c) {
  return tuple(a,b,c,1)
}

// *** COLOR FUNCTIONS

function color(r, g, b) {
  return Object.freeze({ 
    red:r, 
    green:g, 
    blue:b,
    toString: function() { return `red: ${this.red}, green: ${this.green}, blue: ${this.blue}`},
    equals: function(t) { return equal(r, t.red) && equal(g, t.green) && equal(b, t.blue) },
  })
}

function add_colors(c1, c2) {
  // Adding two colors by simple addition
  return color(c1.red + c2.red, c1.green + c2.green, c1.blue + c2.blue)
}

function subtract_colors(c1, c2) {
  // Subtracting two colors by simple subtraction
  return color(c1.red - c2.red, c1.green - c2.green, c1.blue - c2.blue)
}

function multiply_color(s, c1) {
  // Multiply scalar value by r, g, b components
  return color(s * c1.red, s * c1.green, s * c1.blue)
}

function multiply_colors(c1, c2) {
  // Multiply r, g, b components of two colors by each other
  return color(c1.red * c2.red, c1.green * c2.green, c1.blue * c2.blue)
}

function scale_color(c) {
  // Scale the value of a color between 0-255
  // > 1.0 = 255
  //   1.0 = 255
  //   0.5 = 128
  //   0.0 = 0
  // < 0.0 = 0
  
  let red = 255 * c.red
  red = red > 255 ? 255 : red && red < 0 ? 0 : red
  
  let grn = 255 * c.green
  grn = grn > 255 ? 255 : grn && grn < 0 ? 0 : grn
  
  let blu = 255 * c.blue
  blu = blu > 255 ? 255 : grn && blu < 0 ? 0 : blu
    
  //log("error", color(red, grn, blu).toString())
  
  return color(Math.round(red), Math.round(grn), Math.round(blu))
  
}

// *** CANVAS FUNCTIONS

function html_canvas(parent, width, height) {
  // Creates a canvas element as a child of parent, dimensions specified by width and height.
  // Returns the canvas context.
  
  const can = document.createElement("canvas")
  can.setAttribute("width", width)
  can.setAttribute("height", height)
  can.setAttribute("id", parent + "_canvas")
  document.getElementById(parent).appendChild(can)
  
  return can
}


class Canvas {
  // Create a canvas abstraction object. It has a width and a height and a pixel array.
  // Each pixel is defined by three values, r, g, b.
  // The format is a single array or bit stream.
  // To make the array as efficient as possible, we make it a const and pre-initialize length.
  // The RTC book assumes all x and y values are 0-based.
  // So 0 < x < w - 1, and 0 < y < h - 1
  
  constructor(w, h) {
    this.width = w
    this.height = h
    this.bits = 3 // Bits per pixel. rgb = 3. rgba = 4.
    this.d = new Uint8ClampedArray(w * h * b).fill(0)
  }
  
  get width() {return this.width}
  get height() {return this.height}
  get data() {return this.d}
  
  pixel_at(x, y) {
    // Make sure pixels are within the canvas.
    if (x < 0 || y < 0 || x > this.width - 1 || y > this.height - 1) {
      throw `Coordinate values out of bounds: x, y: ${x}, ${y}`
    }
    
    const i = (this.width * y + x) * this.bits
  
    return color(this.d[i], this.d[i+1], this.d[i+2])
  }
  
  write_pixel(x, y, color) {
    // Ignore pixels outside the canvas.
    if (x < 0 || y < 0 || x > this.width - 1 || y > this.height - 1) {
      return
    }
    
    const i = (this.width * Math.round(y) + Math.round(x)) * this.bits
    // For debugging
    //log("error", `w: ${w} h: ${h} x: ${x} y: ${y} i: ${i} color: ${color.toString()} `)
    
    this.d[i]   = color.red
    this.d[i+1] = color.green
    this.d[i+2] = color.blue
    //log("error", `write_pixel: ${this.data[i]}, ${this.data[i+1]}, ${this.data[i+2]}`)
  }
}

function canvas(w, h) {
  // Create a canvas abstraction object. It has a width and a height and a pixel array.
  // Each pixel is defined by three values, r, g, b.
  // The format is a single array or bit stream.
  // To make the array as efficient as possible, we make it a const and pre-initialize length.
  // The RTC book assumes all x and y values are 0-based.
  // So 0 < x < w - 1, and 0 < y < h - 1
  
  const b = 3 // Bits per pixel. rgb = 3. rgba = 4.
  
  //const d = Array(w * h * b).fill(0)
  
  // Typed Array
  const d = new Uint8ClampedArray(w * h * b).fill(0)
  
  //log("error", `w * h * b = ${w} * ${h} * ${b} = ${d.length}`)
  
  return {
    width:w,
    height:h,
    data:d,
    bits:b,
    pixel_at: function(x, y) {
      // Make sure pixels are within the canvas.
      if (x < 0 || y < 0 || x > w - 1 || y > h - 1) {
        throw `Coordinate values out of bounds: x, y: ${x}, ${y}`
      }
      
      const i = (w * y + x) * b
  
      return color(this.data[i], this.data[i+1], this.data[i+2])
    },
    write_pixel: function(x, y, color) {
    // Ignore pixels outside the canvas.
      if (x < 0 || y < 0 || x > w - 1 || y > h - 1) {
        return
      }
      const i = (w * Math.round(y) + Math.round(x)) * b
      // For debugging
      //log("error", `w: ${w} h: ${h} x: ${x} y: ${y} i: ${i} color: ${color.toString()} `)
      
      this.data[i]   = color.red
      this.data[i+1] = color.green
      this.data[i+2] = color.blue
      //log("error", `write_pixel: ${this.data[i]}, ${this.data[i+1]}, ${this.data[i+2]}`)
    }
    }
}

function canvas_to_ppm(can) {
  // Take a canvas object and return a PPM file.
  // The header should look like this, where 80 40 is W and H:
  // P3
  // 80 40
  // 255
  
  let ppm_array = [] // Cannot be typed array, as it will have strings
  let counter = 0
  const bytes = can.width * can.height * can.bits
  const bytes_per_line = Math.floor(70 / (can.bits + 1))
  //log("error", "Bytes per line: " + bytes_per_line)
  //log("error", "Bytes: " + bytes)
  
  for (let k in can.data) {
    ppm_array.push(can.data[k])
    counter++
    if ( counter === bytes_per_line) {
      //log("error", `k: ${k}, ${k % bytes_per_line}`)
      ppm_array.push(`\n`)
      counter = 0
    }
  }
  // End file with a newline
  ppm_array.push(`\n\n`)
  
  // Trim whitespace from each line
  let split = ppm_array.join(" ")
  split = split.split("\n")
  
  for (let i in split) {
    split[i] = split[i].trim()
    split[i] = split[i] + "\n"
  }
  //log("error", split)
  var str = `P3
${can.width} ${can.height}
255
${split.join("")}
`
  return str
}

// *** MATRIX FUNCTIONS

function matrix(rows, cols) {
  // A matrix consists of a bitstream represented in rows * columns
  // For efficiency, a typed array of Float32Array is used, and
  // index value is an integer calculation:
  // m4x4.at(r,c) = (4 * r + c)
  
  const _r = rows
  const _c = cols
  
  const _a = new Float32Array(rows * cols).fill(0)
  //log("error", "_a: " + this._a)

  return Object.freeze({
    rows:_r,
    cols:_c,
    d:_a,
    put: function(row, col, val) { _a[_c * row + col] = val },
    putAll: function(arr) {
      for (let e=0; e < _a.length;e++) {
        _a[e] = arr[e]
      }
    },
    get: function(row, col) { return _a[_c * row + col] },
    submatrix: function(row, col) {
      if((_r-1)*(_c-1) < 4) { throw `Cannot get submatrix < 2x2`}
      
      //__a = new Float32Array((_r-1) * (_c-1)).fill(0)
      temp = []
      // Calculate indexes on row and on col
      const indices = []
      for (let x=0;x<cols;x++) {
        indices.push(cols*row+x)
      }
      for (let x=0;x<rows;x++) {
        indices.push(cols*x+col)
      }
      //log("error", indices)
      const skip = new Set(indices)
      
      for (let i=0;i<_r*_c;i++) {
        if (!skip.has(i)) {
          temp.push(_a[i])
        }
      }
      return Float32Array.of(...temp)
    },
    times_tuple: function(t) {
      // Multiply matrix _a by tuple t.
      // Returns a tuple.
      const result = []
      for (let r = 0; r <= 3; r++) {
        result[r] = 
          parseFloat(this.get(r,0) * t.x) + 
          parseFloat(this.get(r,1) * t.y) + 
          parseFloat(this.get(r,2) * t.z) + 
          parseFloat(this.get(r,3) * t.w)
      }
      return tuple(result[0], result[1], result[2], result[3])
    },
    equals: function(m) {
      const structural_equality = this.rows === m.rows && this.cols === m.cols 
      const elements_equal = []
      if (structural_equality) {
        for (let i=0;i<this.d.length;i++) {
          if ( !equal(this.d[i], m.d[i]) ) {
            //log("error", `These fuckers aren't equal: ${ma.d[i]} and ${mb.d[i]}`)
            elements_equal.push(false)
          } else {
            elements_equal.push(true)
          }
        }
      } else { 
        // Return if structural_equality is false
        return false 
      }
    //log("error", elements_equal)
    return !elements_equal.includes(false)
    },
  })
}

function matrix_equal(ma, mb) {
  throw(`matrix_equal() is deprecated. Use matrix().equals(m) instead.`)
  // Test equality. A === B if Arows === Brows and Acols === Bcols
  //log("error", `matrix_equal(): Running`)
  
  const structural_equality = ma.rows === mb.rows && ma.cols === mb.cols 
  const elements_equal = []
  if (structural_equality) {
   
    for (let i=0;i<ma.d.length;i++) {
    
      if ( !equal(ma.d[i], mb.d[i]) ) {
        //log("error", `These fuckers aren't equal: ${ma.d[i]} and ${mb.d[i]}`)
        elements_equal.push(false)
      } else {
        elements_equal.push(true)
      }
    }
  }
  //log("error", elements_equal)
  return !elements_equal.includes(false)
}

function multiply_matrices(a, b) {
  // Multiply matrices.
  // Only supports 4x4 matrices.
    
  if (a.rows * a.cols != 16 || b.rows * b.cols != 16) {
    throw `Only supports multiplying 4x4 matrices. a = ${a.rows}, b = ${b.cols}`
  }
  const m = matrix(4, 4)
  
  for (let r=0;r<m.rows;r++) {
    for (let c=0;c<m.cols;c++) {
      m.put(r,c,
        a.get(r,0) * b.get(0,c) + 
        a.get(r,1) * b.get(1,c) + 
        a.get(r,2) * b.get(2,c) + 
        a.get(r,3) * b.get(3,c)
      )
     //log("error", `m.get(${r},${c}) = ${m.get(r,c)}`)
    }
  }
  
  return m
}

function multiply_matrix_by_tuple(ma, t) {
  throw(`multiply_matrix_by_tuple() is deprecated. Use matrix().times_tuple(t) instead.`)
  // Multiply matrix by tuple.
  // Returns a tuple.
  
  const result = []
  for (let r = 0; r <= 3; r++) {
    result[r] = 
     ma.get(r,0) * t.x + 
     ma.get(r,1) * t.y + 
     ma.get(r,2) * t.z + 
     ma.get(r,3) * t.w
  }
  
  return tuple(result[0], result[1], result[2], result[3])
}

function idmatrix() {
  // Return an id_matrix
  const m = matrix(4, 4)
  m.put(0,0,1)
  m.put(1,1,1)
  m.put(2,2,1)
  m.put(3,3,1)
  
  return m
}

function transpose_matrix(m) {
  // Turn rows into columns.
  
  const t = matrix(4, 4)
  
  for (let r=0;r<m.rows;r++) {
    //log("error", "r: " + r)
    for (let c=0;c<m.cols;c++) {
     //log("error", "    c: " + c)
     t.put(r,c,m.get(c,r))
    }
  }
  
  return t
  
}

function determinant(m) {
  // Mansplained: Calculate the determinant of a matrix.
  // For a 2x2 matrix
  //   matrix = [a,b,c,d]
  // the calculation is ad - bc.
  // For larger matrices, take the first row and multiply each element with its cofactor.
  // Inputs:
  // m: matrix to calculate determinant for
  // Returns Determinant for matrix, as a number.
  
  let det = 0
  
  if (m.d.length == 4) {
    //log("error", "2x2 determinant")
    det = (m.get(0,0) * m.get(1,1) - m.get(0,1) * m.get(1,0))
  } else {
    //log("error", ">2x>2 determinant")
    for (let i = 0;i<m.cols;i++) {
      det = det + m.get(0,i) * cofactor(m, 0, i)
    }
  }
  
  return det
  
}

function submatrix(mat, row, col) {
  throw `submatrix(mat, row, col) has been deprecated. Use mat.submatrix(row, col) instead.`
}

function minor(ma, row, col) {
  // Mansplained: The minor of an element at row i and column j is the determinant of the submatrix at (i, j).
  // Inputs:
  //   ma: 3x3 array to calculate minor on.
  //   row: submatrix row
  //   col: submatrix column
  // Returns the determinant of the submatrix.
  
  //log("error", ma.join("\n"))
  const sm = matrix(ma.rows-1, ma.cols-1)
  sm.putAll(ma.submatrix(row, col))
  const d = determinant(sm)
  
  return d
}

function cofactor(ma, r, c) {
  // Mansplained: 
  // The cofactor is a possible negation of the minor, depending on which row/col its at.
  // The following figure is helpful:
  // | + - + |
  // | - + - |
  // | + - + |
  // Also, doing a "negate if row + col is odd number" should work.
  // Inputs:
  //   ma: The matrix to calculate cofactor on
  //   r: row to calculate cofactor on
  //   c: col to calculate cofactor on
  // Returns cofactor of matrix at row, col.
  
  const min = minor(ma, r, c)
  
  // Determine if indexes at row+col (r + c) is an odd number and if so, return the negative value of min, else return min.
  //log("error", (r + c) % 2 == 0 ? min : min * -1)
  return (r + c) % 2 == 0 ? min : min * -1
}

function inverse(m) {
  // Mansplained: Calculate the inverse of a matrix
  
  const d = determinant(m)

  if (d === 0) {
    throw "Matrix is not invertible, determinant is 0"
  }
  
  const m2 = matrix(m.rows, m.cols)
  m2.putAll(m.d)
  
  for (let r=0;r<m.rows;r++) {
    for (let c=0;c<m.cols;c++) {
      const cof = cofactor(m, r, c)
      //log("error", "Cofactor: " + cof + ", c: " + c + " r: " + r)
      m2.put(c, r, cof / d)
      //log("error", "New value: " + m2[c][r])
    }
  }
  
  return m2
  
}

function translation(x, y, z) {
  // Returns a 4x4 translation matrix applying the x, y and z coordinates for translation.
  
  if (!isNaN(x) && !isNaN(y) && !isNaN(z) ) {
    const t = idmatrix()
    t.put(0,3,x)
    t.put(1,3,y)
    t.put(2,3,z)

    return t
  } else {
    throw(`Input variable is not a number: x = ${x}, y = ${y}, z = ${z}`)
  }
}

function scale(x, y, z) {
  throw `scale(x, y, z) has been deprecated. Use scaling(x, y, z) instead.`
}

function scaling(x, y, z) {
  //Returns a 4x4 translation matrix applying the x, y and z coordinates for scaling.
  
  if (!isNaN(x) && !isNaN(y) && !isNaN(z) ) {
    // Could have used an idmatrix here, but we save a few cycles by avoiding to set then overwrite coords.
    const t = matrix(4, 4)
    t.put(0,0,x)
    t.put(1,1,y)
    t.put(2,2,z)
    t.put(3,3,1)

    return t
  } else {
    throw(`Input variable is not a number: x = ${x}, y = ${y}, z = ${z}`)
  }
}

function rotation_x(rad) {
  // Takes an angle in radians and returns a rotation matrix for the x-axis
  
  if (!isNaN(rad) ) {
    const cr = Math.cos(rad)
    const sr = Math.sin(rad)
    const t = idmatrix()

    t.put(1,1,cr)
    t.put(1,2,-sr)
    t.put(2,1,sr)
    t.put(2,2,cr)

    return t
  } else {
    throw(`Input variable is not a number: rad = ${rad}`)
  }
}



function rotation_y(rad) {
  // Takes an angle in radians and returns a rotation matrix for the y-axis
  
  if (!isNaN(rad) ) {
    const cr = Math.cos(rad)
    const sr = Math.sin(rad)
    const t = idmatrix()

    t.put(0,0,cr)
    t.put(0,2,sr)
    t.put(2,0,-sr)
    t.put(2,2,cr)

    return t
  } else {
    throw(`Input variable is not a number: rad = ${rad}`)
  }
}

function rotation_z(rad) {
  // Takes an angle in radians and returns a rotation matrix for the z-axis
  
  if (!isNaN(rad) ) {
    const cr = Math.cos(rad)
    const sr = Math.sin(rad)
    const t = idmatrix()

    t.put(0,0,cr)
    t.put(0,1,-sr)
    t.put(1,0,sr)
    t.put(1,1,cr)

    return t
  } else {
    throw(`Input variable is not a number: rad = ${rad}`)
  }
}

function shearing(xy, xz, yx, yz, zx, zy) {
  // Input values for shearing axes in proportion to each other:
  // x in proportion to y
  // x in proportion to z
  // y in proportion to x
  // y in proportion to z
  // z in proportion to x
  // z in proportion to y
  // shearing(xy, xz, yx, yz, zx, zy)
  
  if (!isNaN(xy) && !isNaN(xz) && !isNaN(yx) && !isNaN(yz) && !isNaN(zx) && !isNaN(zy) ) {
    
    const m = idmatrix()
    m.put(0,1,xy)
    m.put(0,2,xz)
    m.put(1,0,yx)
    m.put(1,2,yz)
    m.put(2,0,zx)
    m.put(2,1,zy)

    return m
  } else {
    throw(`Input variable is not a number: xy = ${xy}, xz = ${xz}, yx = ${yx}, yz = ${yz}, zx = ${zx}, zy = ${zy}`)
  }
}

function angle(v) {
  // The angle function converts between degrees and radians and vice versa.
  
  return Object.freeze({
    rad: function() { return (v * (Math.PI/180))},
    deg: function() { return (v * (180/Math.PI))}
  })
}


function transformations(trans) {
  // Transformations given as parameters will be applied in the reverse order
  // We can apply translation, scaling, rotation and shearing into a single operation.
  
  const m = idmatrix()
  
  let t = []
  
  for (let i=0;i<arguments.length;i++) {
    if (arguments[i].d != undefined ) {
      // Only push arguments that are matrices, ie they have .d defined.
      const mat = matrix(arguments[i].rows, arguments[i].cols)
      mat.putAll(arguments[i].d)
      t.push(mat)
    }
  }
  
  //log("error", "transformations(): t[0]) " + t[0].d)
  t = t.reverse()
  
  for (e in t) {
    // To set the result of the multiplied matrices, add .d
    m.putAll(multiply_matrices(m, t[e]).d)
    // log("error", `transformations(): ${e} ${t[e].d}`)
  }
  //log("error", "transformations(): m.d " + m.d)
  
  return m
}

function recursive_transformations(arr) {
  //log("error", "recursive_transformations()" )
  const m = idmatrix()
  const i = arr.pop()
  if (arr.length === 0) {
    //log("error", "recursive_transformations(): " + "array.length=0")
    return multiply_matrices(m, i )
  } else {
    //log("error", "recursive_transformations(): " + "arr.length!=0")
    m.putAll(recursive_transformations(arr ) )
  }
  return m //ultiply_matrices(m, i )
}

// *** RAY FUNCTIONS

function ray(o, d) {
  // Return a "ray", consisting of a point called origin and a vector called direction.
  
  // Check that o is a point and d is a vector, by checking the w value of each
  if (!(o.w === 1 && d.w === 0) ) {
    throw `ray(): Origin must be a point (was ${o.toString()}), and Direction must be a vector (was ${d.toString()})`
  }
  
  return Object.freeze({
    origin:o,
    direction:d,
    transform: function(matr) {
      return ray(
        matr.times_tuple(o), 
        matr.times_tuple(d)
      )
    },
    toString: function() { return `origin: point(${this.origin}) direction: vector(${this.direction})`}
  })
  
}

function position(ray, t) {
  // Compute a ray's direction by t to find the total distance traveled
  return ray.direction.by_scalar(t).plus(ray.origin)
}

class Sphere {
  // The Sphere class represents a sphere object with data. This is the new norm.
  // Default values are set in the constructor and/or parameters.
  // Using getters and setters allows direct assignment, such as sphere.transform = translation(1, 2, 3)
  // Constructor fields are not really private.
  
  constructor() {
    this._id = C.unique_id()
    this._transform = idmatrix()
    this._material = material()
  }
  
  get id() { return this._id }
  get transform() { return this._transform }
  get material() { return this._material }
  get toString() { return `Sphere(), ID: ${this._id}, Transformation matrix: ${this._transform.d}` }
  
  set transform(value) {
    if (value.d != undefined) {
      this._transform = multiply_matrices(this._transform, value)
    }
  }
  
  set material(mat) {
    if (mat.ambient != undefined) {
      this._material = mat
    }
  }
}

function intersect(s, ra) {
  // Intersect returns an array of points where a given ray (ra) intersects a given sphere (s)
  
  // Vector from sphere's center to the ray origin
  // Remember: The sphere is centered at the world origin (0, 0, 0)
  
  const r = ra.transform(inverse(s.transform)) // Ray passed to intersect should be transformed by the inversed transformation matrix

  const sphere_to_ray = r.origin.minus(point(0, 0, 0))
  const a = r.direction.dot(r.direction)
  const b = 2 * r.direction.dot(sphere_to_ray)
  const c = sphere_to_ray.dot(sphere_to_ray) - 1
  
  const discriminant = b**2 - 4*a*c
  
  // The discriminant is the key - if it's negative, the ray misses the sphere
  if (discriminant < 0 ) { return [] }
  
  // Otherwise, the equation has two solutions, which could be the same, if the
  // ray intersects at a perfect tangent
  const t1 = (-b - Math.sqrt(discriminant)) / ( 2 * a )
  const t2 = (-b + Math.sqrt(discriminant)) / ( 2 * a )
  
  return [intersection(t1, s), intersection(t2, s)]
}

function intersection(t_value, sphere) {
  // The intersection function encapsulates t value and object
  
  return Object.freeze({
    t:t_value,
    object:sphere
  })
}

function intersections() {
  // This method takes an arbitrary number of intersection objects as input and
  // aggregates them in an array
  let arr = []
  for (let i=0; i < arguments.length;i++) {
    arr.push(arguments[i])
  }
  return arr
}

function hit(list_of_intersections) {
  // This function returns the intersection with the lowest non-negative number from a list of intersections
  
  if (!Array.isArray(list_of_intersections)) {return } // There are no intersections, return undefined
    
  list_of_intersections = list_of_intersections.filter( item => { if (item.t > 0) {return item}} )
  
  return list_of_intersections.sort().reverse()[0]
}

function transform_old(r, matr) {
  // Transform applies a transformation matrix to a ray
  throw(`Function is deprecated. Use ray().transform(m) instead.`)
}

// *** SHADING FUNCTIONS

function normal_at(obj, world_point) {
  // This function takes an object and a point and returns the point's normal (perpendicular) vector.
  // This is an upgraded version of normal_at(), and will replace that function when done.
  
  const object_point = inverse(obj.transform).times_tuple(world_point)
  const object_normal = object_point.minus(point(0, 0, 0))
  const world_normal = transpose_matrix(inverse(obj.transform)).times_tuple(object_normal)
  
  return vector(world_normal.x, world_normal.y, world_normal.z).normalize()
}

function reflect(v_in, normal) {
  // Reflecting a vector around an incoming in vector and a normal
  // Pseudocode, page 83: return v_in - normal * 2 * v_in.dot(normal)
  
  //log("error", "reflect() v_in: " + v_in)
  //log("error", "reflect() normal: " + normal)
  
  return v_in.minus(normal.by_scalar(2).by_scalar(v_in.dot(normal)))
}

class PointLight {
  // The PointLight class represents a point light object with data.
  // Default values are set in the constructor and/or parameters.
  // Using getters and setters allows direct assignment, such as pointlight.intensity = color(1, 1, 1)
  // Constructor fields are not really private.
  
  constructor(position, intensity) {
    this._id = C.unique_id()
    this._position = position
    this._intensity = intensity
  }
  
  get id() {
    return this._id
  }
  
  get position() {
    return this._position
  }
  
  get intensity() {
    return this._intensity
  }
  
  get toString() {
    return `PointLight(), ID: ${this._id}, position: ${this._position}, intensity: ${this._intensity}`
  }
  
  set intensity(value) {
    if (value.red != undefined) {
      this._intensity = value
    } else {
      throw `Intensity must be a color() object. value = ${value} `
    }
  }
  
  set position(value) {
    if (value != undefined && value.x != undefined) {
      this._position = value
    } else {
      throw `Position must be a point() object. value = ${value} `
    }
  }
}

function point_light(p, i) {
  // Create an object representing a point light in the scene
  
  return new PointLight(p, i)
}

class Material {
  // The PointLight class represents a point light object with data.
  
  constructor() {
    this._id = C.unique_id()
    this._color = color(1, 1, 1)
    this._ambient = 0.1
    this._diffuse = 0.9
    this._specular = 0.9
    this._shininess = 200.0
  }
  
  get color() { return this._color}
  get ambient() { return this._ambient}
  get diffuse() { return this._diffuse}
  get specular() { return this._specular}
  get shininess() { return this._shininess}
  
  set color(col) { this._color = color(col.red, col.green, col.blue) }
  
  set ambient(amb) { this._ambient = amb }
  set diffuse(dif) { this._diffuse = dif }
  set specular(spe) { this._specular = spe }
  set shininess(shi) { this._shininess = shi }

}

function material() {
  // Create an object representing the default material
  
  return new Material()
}

function lighting(material, light, point, eyev, normalv) {
  // The lighting function computes shading for pixels
  
  // Combine surface color with the light's color/intensity
  const effective_color = multiply_colors(material.color, light.intensity)
  //log("error", "effective_color: " + effective_color)
  
  // Find the direction to the light source
  const lightv = light.position.minus(point).normalize()
  //log("error", "lightv: " + lightv)
  
  // Compute ambient contribution
  const ambient = multiply_color(material.ambient, effective_color)
  //log("error", "ambient: " + ambient)
  
  let diffuse, specular
  // light_dot_normal represents the cosine of the angle between the light vector and 
  // the normal vector. A negative number means the light is on the other side of the
  // surface.
  const light_dot_normal = lightv.dot(normalv)
  //log("error", "light_dot_normal: " + light_dot_normal)
  
  if (light_dot_normal < 0) {
    diffuse = color(0, 0, 0)
    specular = color(0, 0, 0)
  } else {
    // Compute the diffuse contribution
    diffuse = multiply_color(material.diffuse * light_dot_normal, effective_color)
    //log("error", "diffuse: " + diffuse)
    
    // reflect_dot_eye represents the cosine of the angle between the reflection vector
    // and the eye vector. A negative number means the light reflects away from the eye.
    // According to the book, it should be -lightv. But I saw no specular highlight while that was the case.
    // When I (by chance) changed it to lightv, the highlight is there!
    const reflectv = reflect(lightv, normalv)
    //log("error", "reflectv: " + reflectv)
    
    const reflect_dot_eye = reflectv.dot(eyev)
    //log("error", "reflect_dot_eye: " + reflect_dot_eye)
    
    if (reflect_dot_eye <= 0 ) {
      specular = color(0, 0, 0)
    } else {
      // Compute the specular contribution
      const factor = Math.pow(reflect_dot_eye, material.shininess)
      
      specular = multiply_color(material.specular * factor, light.intensity)
      //log("error", "light.intensity: " + light.intensity)
      //log("error", "material.specular: " + material.specular)
      //if (specular.red >= 0.01) {log("error", "specular.red: " + specular.red)}
    }
  }
  // Add the three contributions together to get the final shading
  //log("error", `ambient + diffuse + specular = " ${ambient} + ${diffuse} + ${specular} = ${add_colors(ambient, add_colors(diffuse, specular))}`)
  return add_colors(ambient, add_colors(diffuse, specular))
}

</script>

<script>
// *** TRANSFORMATION MATRIX CALCULATOR

// Using functions.js, we can visualise how matrix calculations work.

// Performance counter



// Performance measurement
const end = performance.now()
const elapsed = end - start
const cumulated_id = "matrix_calculator_running_time"
const numberOfRuns_id = "matrix_calculator_runs"

const cumulated = localStorage.getItem(cumulated_id)
const runs = localStorage.getItem(numberOfRuns_id)

localStorage.setItem(numberOfRuns_id, Number(runs) + 1)
localStorage.setItem(cumulated_id, Number(cumulated) + elapsed)

log("perf", "Calculation running time: " + Math.round(elapsed) + " ms.")
log("perf", "Average running time: " + (cumulated / runs).toFixed(4) + " ms.")
</script>

</body>

</html>